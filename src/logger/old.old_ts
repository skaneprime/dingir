import chalk from 'chalk'
import moment from 'moment'

function OldLoggerBoxForm_IT_DOES_THE_JOB_BUT_NOT_CORRECTLY() {
    function makeBox(
        tagName: string, 
        levelName: string, 
        color?: string,
    ) {
        const Space = (hex: string, defVal: string) => 
            chalk.bgHex(hex)( ' '.repeat(defVal.length)) 

        const tag = chalk.hex('#bdbdbd').bold.bgHex('#303030')(tagName)
        const level = chalk.hex('#303030').bold.bgHex(color || "#2eff8f")(levelName)
        
        return `${tag}${level}`
    }
    const args = ['asasa', { a: '', b: 1, x: [1,''] }]
    console.log( makeBox(' TSER  ', ' DEBUG ',"#adadad"),  ...args )
    console.log( makeBox(' TSER  ', ' INFO  ',),           ...args )
    console.log( makeBox(' TSER  ', ' WARN  ', "#ecff40"), ...args )
    console.log( makeBox(' TSER  ', ' ERROR ', "#fc4f30"), ...args )
    console.log( makeBox(' TSER  ', ' FATAL ', "#ff9233"), ...args )
}

type Styles = {
    bold?: boolean
    underline?: boolean
    strike?: boolean
}
type Colors<T extends string> = T | `${T}BgColor` | `${T}Color`
type ColorKeys = Colors<"time"> | Colors<"label"> | Colors<"level">
type WriteOptions = { 
    [key in Exclude<ColorKeys, 'time'>]?: string 
} & {
    [key in 'timeStyle' | 'labelStyle' | 'levelStyle']?: Styles
} & { 
    style: 'min' | 'big' | undefined
    time?: boolean
}

// interface Theme {
//     time?: string
//     timeBg?: string

//     label?: string
//     labelBg?: string
    
//     level?: string
//     levelBg?: string
//     colors: {
//     }
// }

interface LoggerOptions {
    label: string
    labelBgColor?: string
    labelColor?: string
    timeEnabled?: boolean
    disableBg?: boolean
}
// Implement Themes and shablones
export class Logger {
    Themes = []
    Instance = Logger
    private defaultTimeBgColor = "#262626"
    private defaulLabelBgColor = "#262626"
    private defaultLevelBgColor = "#545454"
    private defaultStringColor = "#949494"
    
    constructor(public options?: LoggerOptions) {}
    
    SetOptions = (options: LoggerOptions) =>
        this.options = options

    Write(opts: WriteOptions, args: any[]) {
        const disableBg = this.options?.disableBg

        const timeColor = opts.timeColor || this.defaultStringColor
        const timeBgColor = opts.timeBgColor || this.defaultTimeBgColor
        
        const labelColor = opts.labelColor || this.defaultStringColor
        const labelBgColor = opts.labelBgColor || this.defaulLabelBgColor
        
        const levelColor = opts.levelColor || this.defaultStringColor
        const levelBgColor = opts.levelBgColor || this.defaultLevelBgColor
    
        const time  = opts.time  ? ` ${moment().format('HH:mm:ss')} ` : ''
        const label = opts.label ? ` ${opts.label} ` : ''
        const level = opts.level ? ` ${opts.level} ` : ''
    
        function getHeader() {
            const headerLen = process.stdout.columns - label.length - level.length - time.length
            const headerStr = " ".repeat(headerLen)
            return chalk.bgHex(levelBgColor)(headerStr)
        }

        function emptyStr(hex: string, strLen: number) {
            const str = " ".repeat(strLen)
            return chalk.bgHex(hex)(str)
        }

        function Colorize(
            hexColor: string, 
            bgHexColor: string, 
            str: string,
            styles?: Styles
        ) {
            str = chalk.hex(hexColor)(str)
            if(!disableBg) str = chalk.bgHex(bgHexColor)(str)

            if(styles?.bold) str = chalk.bold(str)
            if(styles?.underline) str = chalk.underline(str)
            if(styles?.strike) str = chalk.strikethrough(str)

            return str
        }
        
        const titles = 
            Colorize(timeColor,  timeBgColor,   time, opts.timeStyle) + 
            Colorize(labelColor, labelBgColor, label, opts.labelStyle) + 
            Colorize(levelColor, levelBgColor, level, opts.levelStyle)

        switch (opts.style || 'min') {
            case 'big':
                const spaces = 
                    emptyStr(timeBgColor, time.length) + 
                    emptyStr(labelBgColor, label.length) + 
                    emptyStr(levelBgColor, level.length)
                
                return console.log(`${titles}${getHeader()}\x1b[K${spaces}`, ...args, '\x1b[K')
            case 'min':
                return console.log(`${titles}`, ...args)
        }
    }

    WriteOptions: WriteOptions = {
        time: this.options?.timeEnabled,

        label: this.options?.label,
        labelBgColor: this.options?.labelBgColor,
        labelColor: this.options?.labelColor,
        labelStyle: { bold: true },
        
        levelColor: "#333333",
        levelStyle: { bold: true },

        timeColor: '#26dbff',
        style: 'min'
    }

    private Log = (levelData: any, args: any[]) => 
        this.Write({ ...levelData, ...this.WriteOptions }, args)
    
    Debug = Object.assign(
        (...args: any[]) => this.Log(this.Debug, args), { 
            level: 'DEBUG', levelBgColor: "#b5b5b5" 
    }) 

    Info  = Object.assign(
        (...args: any[]) => this.Log(this.Info, args), { 
            level: 'INFO ', levelBgColor: "#55ff26" 
    })

    Warn  = Object.assign(
        (...args: any[]) => this.Log(this.Warn, args), { 
            level: 'WARN ', levelBgColor: "#e9ff26" 
    })

    Error = Object.assign(
        (...args: any[]) => this.Log(this.Error, args), { 
            level: 'ERROR', levelBgColor: "#ff5526" 
    })

    Fatal = Object.assign(
        (...args: any[]) => this.Log(this.Fatal, args), { 
            level: 'FATAL', levelBgColor: "#ff2659", style: 'big' 
    })
}


(function tset() {

    const l = new Logger({ 
        label: 'TSER ', 
        timeEnabled: true 
    })
    setInterval(() => {    
        l.Debug( randomString(10), createRandomObj( Math.floor( Math.random() * 5), true) )
        l.Info( randomString(10),  createRandomObj( Math.floor( Math.random() * 5), true) )
        l.Warn( randomString(10),  createRandomObj( Math.floor( Math.random() * 5), true) )
        l.Error( randomString(10), createRandomObj( Math.floor( Math.random() * 5), true) )
        l.Fatal( randomString(10), new Error( randomString(10) ) )
    }, 2000)
    
    function createRandomObj(fieldCount: any, allowNested: any) {
        var generatedObj = {} as any;
    
        for(var i = 0; i < fieldCount; i++) {
            var generatedObjField;
    
            switch(randomInt(allowNested ? 6 : 5)) {
    
                case 0:
                generatedObjField = randomInt(1000);
                break;
    
                case 1:
                generatedObjField = Math.random();
                break;
    
                case 2:
                generatedObjField = Math.random() < 0.5 ? true : false;
                break;
    
                case 3:
                generatedObjField = randomString(randomInt(4) + 4);
                break;
    
                case 4:
                generatedObjField = null;
                break;
    
                case 5:
                generatedObjField = createRandomObj(fieldCount, allowNested);
                break;
            }
            generatedObj[randomString(8)] = generatedObjField;
        }
        return generatedObj;
    }
    
    // helper functions
    
    function randomInt(rightBound: any) {
        return Math.floor(Math.random() * rightBound);
    }
    
    function randomString(size: any)
    {
        var alphaChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var generatedString = '';
        for(var i = 0; i < size; i++) {
            generatedString += alphaChars[randomInt(alphaChars.length)];
        }
    
        return generatedString;
    }
})()